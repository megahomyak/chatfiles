since control needs to travel, so should ownership

control:
* getting the first line
* iterating over the first line
* getting the next line
* ...

initially, control is in the line char, we can either advance once or skip to the next line
not only can we advance once (gives control to next line char) or skip to the next line (gives control to next line, if doesn't exist - it's as if we called "end"), we can also start going from the end (gives control to BackLines)

control flow: line -> nexter -> prever ; it is possible to jump from any point in the control flow to any further point. likely done through methods on types that will get to the next type, but that operation alone probably shouldn't do stuff UNLESS the stuff's inevitable
actually, line_forward -> nexter -> line_backwards -> prever
line_forward { next_char(&mut self) -> Result<char, ()>, end() -> nexter }
nexter { next_line() -> Result<line_forward, line_back>, end() -> line_back }
line_back { next_char(&mut self) -> Result<char, ()>, end() -> prever }
prever { prev_line() -> Result<line_back, ()> }
->
line_forward { next_char(&mut self) -> Result<char, ()>, next_line() -> Result<line_forward, line_back>, end() -> line_back }
line_back { next_char(&mut self) -> Result<char, ()>, prev_line() -> Result<line_back, ()> }
->
line_forward { next_line(self) -> Result<line_forward, line_back>, end(self) -> line_back } + Iterator<Item = char>
line_back { prev_line(self) -> Option<line_back> } + Iterator<Item = char>
->
same, but with iter() to have nice next() and prev() without name collisions

the last position is outlawed if it's a newline character (i.e. can: "<cursor>\n<EOF>", can't: "\n<cursor><EOF>"). since the "end()" may take me there and the "next()" may take me there, I think in both of them I should make the "\n" check. essentially, since in both cases I end up at "\n<cursor><EOF>", I need to check if that's the case (I need to go in two directions: forwards and backwards. if there's nothing forwards and an \n backwards, i need to return a signifying bool (signifying a move backwards into a stable position - did the move happen?); the bool will be ignored by the end() function, but used by next() to return a None)

forward_line:
* iter: obvious
* next: going to the next line. are we at the end? if yes, switch to back_line

ATTEMPT:
nexter = make_nexter(cursor) <- control here
prever = loop {
    match nexter.next() {
        impossible(prever) => break prever, <- control here
        possible((kind, line)) => { <- control here
            if kind is special {
                nexter = loop {
                    match line.next() {
                        impossible(nexter) => break nexter,
                        possible(char) => ...,
                    }
                };
            }
        },
    }
};
